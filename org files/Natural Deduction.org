* Variables
First of all, some variables. In order for the package to work, we will need to identify the respective columns. Depending on the language you choose, though, they may be labelled differently. Although it would, in principle, be possible to identify all of them by means of the content of their cells, it is more straight forward to provide variables.

#+BEGIN_SRC elisp :exports code :results nil :tangle natural-deduction.el
  (defcustom tlt-nd-stars '(1 "Sterne")
    "Number and name of the star column.")

  (defcustom tlt-nd-rowname '(2 "Zeile")
    "Number and name of the column to be numbered.")

  (defcustom tlt-nd-formulas '(3 "Formel")
    "Number and name of the formula column.")

  (defcustom tlt-nd-reference '(4 "Bezug")
    "Number and name of the reference column.")

  (defcustom tlt-nd-rule '(5 "Regel")
    "Number and name of the rule column.")

  (defcustom tlt-nd-hyp "Hyp"
    "Name of the assertion tlt-nd-rule.")

  (defcustom tlt-nd-capitalize t
    "Whether to capitalize rules automatically when aligning the table.")

  (defcustom tlt-nd-no-ref-rules '(tlt-nd-none tlt-nd-new)
    "Functions of rules which do not reference any line.")
#+END_SRC

#+RESULTS:
: tlt-nd-no-ref-rules

** Proof rules
#+BEGIN_SRC elisp :exports code :results none
  (defcustom tlt-nd-rule-hyp '(:rule hyp
                                  :names ("Hyp" "$Hyp$" "Hypothesis")
                                  :refs 0
                                  :star-function tlt-nd-new
                                  :args (list row starcol hypno hyps-total))
    "Rule for introducing a hypothesis.")

  (defcustom tlt-nd-rule-intro-and '(:rule intro-and
                                        :names ("$I\\land$" "I&")
                                        :refs 2
                                        :star-function tlt-nd-unite
                                        :args (list starcol row hyplist))
    "Rule for introducing a conjunction.")

  (defcustom tlt-nd-rule-intro-or '(:rule intro-or
                                       :names ("$I\\lor$" "Iv")
                                       :refs 1
                                       :star-function tlt-nd-adopt
                                       :args (list row starcol refnums))
    "Rule for introducing a disjunction.")

  (defcustom tlt-nd-rule-elim-if '(:rule elim-if
                                      :names ("$E\\to$" "E->")
                                      :refs 2
                                      :star-function tlt-nd-unite
                                      :args (list starcol row hyplist))
    "Rule for eliminating a conditional.")

  (defcustom tlt-nd-rule-special-proven '(:rule special-proven
                                             :names ("AL" "PC" "" "PL" "S1" "S2" "S3" "S4" "S5")
                                             :refs 2
                                             :star-function tlt-nd-none
                                             :args (list row starcol hypcount))
    "Rule for introducing a formula already proved.")

  (defcustom tlt-nd-rule-special-elim-multi-if '(:rule special-elim-multi-if
                                                    :names ("$I\\to_+$" "$I\\to_{+}$" "I->+")
                                                    :refs n
                                                    :star-function tlt-nd-intersect
                                                    :args (list starcol row hyplist))
    "Rule for eliminating several hypotheses at once.")

  (defcustom tlt-nd-proof-rules '(tlt-nd-rule-hyp tlt-nd-rule-intro-and tlt-nd-rule-intro-or 
                                               tlt-nd-rule-elim-if tlt-nd-rule-special-proven 
                                               tlt-nd-rule-special-elim-multi-if)
    "List of rules to be considered for natural deduction proofs.")
#+END_SRC
** Anderes
#+BEGIN_SRC elisp :exports code
  (defvar tlt-nd-table nil
    "The table last fetched by `tlt-nd-get-table'.")
#+END_SRC

#+RESULTS:
: tlt-nd-table

* Storing the Table
For any operation to come, we need the table stored in an object. The procedure to get a function which returns such an object is straight-forward:
1. Define a function to go to the next table cell until a specific point.
2. Define a function to fetch all cells of a row to get a single row.
3. Define a function to fetch all rows to get get the whole table.
#+BEGIN_SRC elisp :exports code
  (defun tlt-nd-capitalize-first-char (string)
    "Return STRING, first char capitalized.
        Return zero-length strings as-is."
    (if (equal string "") ""
      (concat (upcase (substring string 0 1)) (substring string 1))))

  (defun tlt-nd-next-field-until (end)
    "Go to the next field. Return nil if at END.
    Great parts copied from `org-table-next-field'."
    (let ((org-table-tab-jumps-over-hlines t))
      (condition-case nil
          (progn
            (re-search-forward "|" end)
            (if (looking-at "[ \t]*$")
                (re-search-forward "|" end))
            (if (looking-at "-")
                (re-search-forward "^[ \t]*|\\([^-]\\)" end t)
              (goto-char (match-beginning 1))))
        (error (if (equal end (point))
                   nil t)))))

  (defun tlt-nd-next-field ()
    "Go to the next field. Return nil if at the end of the table."
    (tlt-nd-next-field-until (1- (org-table-end))))

  (defun tlt-nd-get-row ()
    "Return a list of the contents of every cell in the row at hand.
    The strings are trimmed, capitalized and without properties."
    (let ((rowend (re-search-forward "|\s*$" nil t))
          (org-table-tab-jumps-over-hlines t)
          (search t)
          (row nil))
      ;; If not at the beginning of line, go there ;;
      (unless (bolp) 
        (beginning-of-line))
      ;; move point right of the first occurrence of "|" ;;
      (re-search-forward "|")
      ;; get the field at hand and push it to `row' until row ends ;;
      (while search
        (looking-at "[^|\r\n]*")

        (let* ((field-trim 
                       (org-trim                         ; trimm
                        (buffer-substring-no-properties  ; remove properties
                         (match-beginning 0)
                         (match-end 0))))
              (field
          ;; Capitalize depending on custom variable ;;
          (if tlt-nd-capitalize 
                (tlt-nd-capitalize-first-char field-trim)
                 field-trim))
            ; (field (concat " " field-maybe-cap))

)

            (push field row))

        (setq search (tlt-nd-next-field-until rowend)))
      ;; return row ;;
      (reverse row)))

  (defun tlt-nd-get-table ()
    "Store the table at hand."
    (let ((end (org-table-end))
          (search t)
          (table nil))
      (save-excursion
        (goto-char (org-table-begin))
        ;; Loop
        (while search
          (push 
           (tlt-nd-get-row)
           table)
          (setq search (tlt-nd-next-field)))
        ;; return table
        (setq tlt-nd-table (reverse table)))))
#+END_SRC

#+RESULTS:
: tlt-nd-get-table

* Accessing Rows, Columns, Fields
We will need to access rows, columns and fields to update the table. Below are the functions which allow this.
#+BEGIN_SRC elisp :exports code
  (defun tlt-nd-line (line)
    "Get list for line number LINE stored in `tlt-nd-table'. 
  Set the variable if it is nil."
    (if tlt-nd-table
        (nth (1- line) tlt-nd-table)
      (nth (1- line) (tlt-nd-get-table))))

  (defun tlt-nd-column (colnum)
    "Get column number COLNUM."
    (unless tlt-nd-table (tlt-nd-get-table))
    (let ((counter 1)
          (length (length tlt-nd-table))
          (col nil))
      (while (<= counter length)
        (push
         (nth (1- colnum) 
              (tlt-nd-line counter))
         col)
        (setq counter (1+ counter)))
      (reverse col)))

  (defun tlt-nd-column-headless (colnum)
    "Get column number COLNUM without headlines."
    (cdr (tlt-nd-column colnum)))

  (defun tlt-nd-row (row)
    "Get row number ROW. Disregard header."
    (if tlt-nd-table
        (nth row tlt-nd-table) ; not -1 to disregard header
      (nth row (tlt-nd-get-table))))

  (defun tlt-nd-field (colnum row)
    "Get field in column COLNUM and row ROW."
    (nth (1- colnum) (tlt-nd-row row)))
#+END_SRC

#+RESULTS:
: tlt-nd-field
* Changing the Table
** Generic functions
#+BEGIN_SRC elisp :exports code
  (defun tlt-nd-set-field (colnum row value)
    "Set field in column COLNUM and row ROW of `tlt-nd-table' to VALUE."
    (setf  (nth (1- colnum) (tlt-nd-row row)) value))

  (defun tlt-nd-nth-char (n string)
    "Return Nth char in STRING. Nth is zero-based."
    (substring string (1- n) n))

  (defun delete-star (wrong-star str)
    "Replace '+' at position WRONG-STAR in STR by '-'."
    ;; replace the wrong-star by a "-"
    (replace-regexp-in-string  ; replace any "+" at level star-level-act
     (format "\\(^ [\\+\\-]\\{%d\\}\\)\\(\\+\\)\\([\\+\\|\\-]*\\)" (1- wrong-star)) ; 1- because we exclude them so the first char is the star level

     ;;  first group: all occurrences of "+" or "-" until, excluding, `right-star' - anything before
     ;;  second group: exactly one occurrence of "+" or "-": the one to replace  ;;
     ;;  third group: zero or more occurrences of "+" or "-"  - anything after              ;;
     "\\1-\\3" ; the wrong star is replaced by a "-"
     ;;  first group, second group replaced by ";%d;", third group          ;;
     str))

  (defun add-star (right-star str)
    "Replace '+' at position WRONG-STAR in STR by '-' and, if RIGHTPLUS it non-nil,
    replace '-' at position RIGHT-STAR in STR by '+'."
    (replace-regexp-in-string  ; replace any "+" at level star-level-act by ";star-amount;" if it exists
     (format "\\(^ [\\+\\-]\\{%d\\}\\)\\([\\+\\|\\-]\\)\\([\\+\\|\\-]*\\)" (1- right-star)) ; 1- because we exclude them so the first char is the star level

     ;;  first group: all occurrences of "+" or "-" until, excluding, `right-star' - anything before
     ;;  second group: exactly one occurrence of "+" or "-": the one to replace  ;;
     ;;  third group: zero or more occurrences of "+" or "-"  - anything after              ;;
     "\\1+\\3" ; the wrong star is replaced by a "-"
     ;;  first group, second group replaced by ";%d;", third group          ;;
     str))
#+END_SRC

#+RESULTS:
: add-star

** Correct Rows and Reference Numbers
*** Preliminary Functions
In order to automatically correct the line numbers, we need a way to replace the old ones by the new ones. The line numbers are strings, for example "2" or "5", and =adjust-numbers= stores them in a list. To change the wrong numbers now, we need to replace the corresponding wrong strings with respective right strings. And this is what =replace-string-in-list= does.

Similarly, we will also need to order the row numbers, so we will need to order a list of number strings. This is the job of =order-list-string-int=.
#+BEGIN_SRC elisp :exports code
  (defun replace-string-in-list (old new list)
    "Return the result of replacing OLD by NEW in LIST."
    (let ((outlist))
      (dolist (element list outlist)
        (if (equal element old)
            (push new outlist)
          (push element outlist)))
      (reverse outlist)))

  (defun order-list-string-int (list)
    "RETURN LIST ordered by the numbers as strings which are its members."
    (let* ((unquoted (mapcar #'string-to-number list)) ; important: (string-to-number "m3") returns 0!
           (sorted (sort unquoted #'<=)))
      (mapcar #'int-to-string sorted)))

  (defun order-string (string)
    "RETURN the STRING containing numbers ordered by these numbers."
    (let* ((clean (gnus-strip-whitespace                     ; raw numstring
                   (substring-no-properties string)))                 ; with properties removed
           (list (split-string clean ","))
           (sorted (order-list-string-int list))
           (sorted-string (string-join sorted ",")))
      (if (equal sorted-string "0") "-"
        sorted-string)))
#+END_SRC

#+RESULTS:
: order-string

*** The Actual Function
Let's say that for some reason, row no. 4 was labelled with "3". So far, the function replaces every occurrence of "3" in the reference column by "4". Now imagine that row no. 5 was accidentally labelled "4". Now, every occurrence of "4" will be labelled "5" -- also those which were just converted into "4". To avoid that, we temporarily change the numbers' names: "3" becomes "4mark" instead of "4" so that it will not get replaced.
#+BEGIN_SRC elisp :exports code :results nil :tangle natural-deduction.el
  (defun adjust-numbers ()
    "Adjust numbers."
    (let* ((ref (car tlt-nd-reference))                                    ; 2 aus (2 "Zeile")
           (row (car tlt-nd-rowname))                                      ; 4 aus (4 "Bezug")
           (lines (length tlt-nd-table))                               ; number of lines +1
           (org-table-allow-automatic-line-recalculation nil)              ; done with `ctrl-c-ctrl-c-hook' later anyway
           (org-table-automatic-realign nil)
           (refs (tlt-nd-column-headless ref))
           (rownum 1))                                                     ; to loop over row name;

      ;; Looping over the ROW numbers ;;

      (while (< rownum lines)
        (let* ((rownum-str (int-to-string rownum))                         ; 1 → "1"
               (actnum (tlt-nd-field row rownum))
               (counter2 1))                                               ; second counter to loop over tlt-nd-references list

          (unless (equal (int-to-string rownum) actnum)                    ; if the row number is wrong (convert counter bc actnum is a string)
            (tlt-nd-set-field row rownum rownum-str)                       ; set it to the right one

            ;; Looping over the TLT-ND-REFERENCE numbers ;;                ; change all wrong numbers to the right ones in the tlt-nd-reference column

            (while (< counter2 lines)
              (let* ((numstring (nth (1- counter2) refs))
                     (refnums (split-string numstring ","))                ; tlt-nd-reference cell in form ("REF1" "REF2" "REF3")

                     (wrongnum actnum)                                     ; the wrong number is the actual number in string form (under the above condition)
                     (rightnum rownum-str)                                 ; the right number is the rownumber
                     (rightnum-marked (concat "m" rightnum))               ; the right number marked with "m", e.g. "m2"

                     (refnums-right-list
                      (replace-string-in-list wrongnum rightnum-marked refnums))      ; replace all occurrences of the wrongnum in refnums by the marked rightnum

                     (refnums-right-str (string-join refnums-right-list "," )))       ; and make a string out of it

                (unless (or                                               ; unless the ref field is empty (else the ref field would get the row number of the empty field)
                         (equal numstring "")                             ; that is the empty string
                         (equal numstring "-"))                           ; or "-"
                  (tlt-nd-set-field ref counter2 refnums-right-str)       ; put the new string back in the field
                  (message "counter2: %s, refnums: %s, refnums-right-list: %s, refnums-right-str: %s" counter2 refnums refnums-right-list refnums-right-str))

                (setq counter2 (1+ counter2)))))                           ; in any case, whether changed or not, increment the counter by 1


          (setq rownum (1+ rownum)))   ; whether the tlt-nd-reference numbers were changed or not: increment the counter by 1

        ;; Lastly, after every tlt-nd-reference cell has been changed, remove the marks and sort them ;;

        (let ((counter3 2))                                                   ; create a third and last counter
          (while (< counter3 lines)                                           ; and loop over every row
            (let* ((marked (tlt-nd-field ref counter3))

                   (unmarked (replace-regexp-in-string "m" "" marked))
                   (sorted (order-string unmarked))
                   (forms (car tlt-nd-formulas)))

              (unless (equal (org-table-get counter3 forms) "")  ; unless the formula cell is empty
                (tlt-nd-set-field ref counter3 sorted)))  ; put the new number in there

            (setq counter3 (1+ counter3)))))))
#+END_SRC

#+RESULTS:
: adjust-numbers
* Executing Proof Rules
#+BEGIN_SRC elisp :exports code
      (defun tlt-nd-find-rule (rulestring)
        "Return that plist in `tlt-nd-proofrules' one of whose :names is RULESTRING, or an error message."
        (let ((right-rule)
              (rulenum (length tlt-nd-proof-rules))
              (counter 1))
          (while (<= counter rulenum)
            (let* ((rulevar (nth (1- counter) tlt-nd-proof-rules))
                   (rule (eval rulevar)) ; eval necessary because rulevar is just a sign
                   (rulenames (plist-get rule :names)))
              (if (member rulestring rulenames)
                  (progn
                    (setq right-rule rule)
                    (setq counter rulenum))
                (setq counter (1+ counter)))))
    (if right-rule right-rule
    (error "No rule called \"%s\" within tlt-nd-proof-rules" rulestring))
          right-rule))

      (defun tlt-nd-trace-hypotheses (starcol refnums)
        "Return a list of the starstrings in the rows in REFNUMS, 
    where STARCOL is the number of the column in which the stars are.
    STARCOL is an integer, REFNUMS a list of integers."
        (let ((hyplist))
          (dolist (ref refnums)
            (push (tlt-nd-field starcol ref) hyplist))
          hyplist))

      (defun tlt-nd-count-hyps ()
        "Return the number of hypotheses in `tlt-nd-table'."
        (let ((hypcount 0)
              (counter 1)
              (lines (length tlt-nd-table)))
          (while (< counter lines)
            (let* ((row (tlt-nd-row counter))
                   (rulecol (1- (car tlt-nd-rule)))
                   (rule (string-trim-left (nth rulecol row)))
                   (hypnames (plist-get tlt-nd-rule-hyp :names)))
              (when (member rule hypnames)
                (setq hypcount (1+ hypcount)))
              (setq counter (1+ counter))))
          hypcount))

      (defun tlt-nd-none (row starcol hyps-total)
        "Set the starfield in row ROW and column STARCOL to be a string of HYPS-TOTAL occurrences of '-'.
    ROW, STARCOL and HYPS-TOTAL are integers."
        (let ((stars-right (make-string hyps-total ?-)))
          (tlt-nd-set-field starcol row stars-right)
    stars-right))

      (defun tlt-nd-new (row starcol hypno hyps-total)
        "Set the starfield in row ROW and column STARCOL to a string of HYPS-TOTAL characters, consisting of occurrences of '-', except for position HYPS-TOTAL, which is '+'.
    ROW, STARCOL, HYPNO and HYPS-TOTAL are integers."
        (let ((stars-right (concat " " (fill-star hyps-total (format "%s+" (make-string (1- hypno) ?-))))))
          (tlt-nd-set-field starcol row stars-right)
    stars-right))

      (defun tlt-nd-adopt (row starcol refnums)
        "Adopt the stars of REFNUMS in row ROW and column STARCOL.
    ROW and STARCOL are integers, REFNUMS is a list of integers."
        (let ((right-star (tlt-nd-field starcol (car refnums))))
          (tlt-nd-set-field starcol row right-star)
    right-star))
#+END_SRC

** Uniting and intersecting strings   
Since our hypotheses all start with a whitespace, our initial string should do that, too, so we're adding it. Do keep it at the right length, we just take the first star-string in the list, get its length and subtract it by one.

The idea behind =tlt-nd-intersect= is:
1. Create a string starting with a whitespace and containing just occurrences of "+" after that.
2. Loop over the characters of the elements:
   1. If at position n (the one after the whitespace) of element m is a "-", change the string's "+" at n to a minus.
      1. If at position n+1 of character m, ....
   2. If at position n of character m+1, ....
This way, we're ending up with the string we want.

=tlt-nd-unite= works similarly, we just start of with a string whose characters are, except for the first one, only occurrences of "-", and adding occurrences of "+".
#+BEGIN_SRC elisp :exports code
      (defun tlt-nd-intersect (starcol row hyplist)
        "Return a string such that at position pos, there is a '+' iff 
          it ouccurs at pos for every element of HYPLIST, and '-' else.

          Assumes that all hyplist have the same length.
          Supposed to be called after `fill-star'."
        (let* ((right-star (concat " " (make-string (1- (length (car hyplist))) ?+))))
          (dolist (stars hyplist)
            (let ((position 2))
              (while (<= position (length stars))
                (let* ((str (tlt-nd-nth-char position stars)))
                  (when (equal str "-")
                    (setq right-star 
                          (delete-star (1- position) right-star))))
                (setq position (1+ position)))))
          (tlt-nd-set-field starcol row right-star)))

    (defun tlt-nd-unite (starcol row hyplist)
      "Return a string such that at position pos, '+' is added iff
        it occurs at pos for at least one element of STRINGS, and '-' else.

        Assumes that all strings have the same length."
      (let* ((right-star  (concat " "         ; whitespace to prevent "|-" and, thus, hline
  (make-string (1- (length (car hyplist))) ?-)))) ; just take the list's first string; they all have the right length anyway
        (dolist (stars hyplist)
          (let ((position 2))
            (while (<= position (length stars))
              (let* ((str (tlt-nd-nth-char position stars)))
                (when (equal str "+")
                  (setq right-star 
                        (add-star (1- position) right-star))))
              (setq position (1+ position)))))
          (tlt-nd-set-field starcol row right-star)))
#+END_SRC
* Adjusting the Star Cells
** Tracing Function
#+BEGIN_SRC elisp :exports code

#+END_SRC

#+RESULTS:

** COMMENT Get a List by its nth Member 
#+BEGIN_SRC elisp :exports code :results nil :tangle natural-deduction.el
  (defun get-by-nth (list n value)
    "Get member of LIST whose Nth member is VALUE.
    N is 1-based."
    (let ((max (length list))
          (counter 1)
          (result))
      (while (not (or result (> counter max))) ; until we have a result or the counter is at max
        (let ((element (nth (1- counter) list))) ; -1 because `nth' is 0-based
          (if (equal (nth (1- n) element) value)
              ;; if the nth value of element is the value we're looking for ;;

              ;; set the counter to max so that it stops ;;
              ;; and return the element                  ;;
              (progn
                (setq result element)
                (setq counter (1+ max)))
            (setq counter (1+ counter)))))

      ;; if it is not, increment the counter by 1 ;;
      (if result result
        ;; If it is at max, return an error message ;;
        (error "No member of %s whose %s%s value is %s"
               list n
               (let* ((num (int-to-string n))
                      (digits (length num))
                      (lastdigit (tlt-nd-nth-char digits num)))
                 (cond ((equal lastdigit "1") "st")
                       ((equal lastdigit "2") "nd")
                       ((equal lastdigit "3") "rd")
                       (t "th")))
               value))))
#+END_SRC

#+BEGIN_SRC elisp :exports code :results none :tangle natural-deduction.el
  ;;; Example
  (setq a '((1 2 3) (a 5 7) (b 3 9)))
  (setq n 1)
  (get-by-nth a 2 5)
#+END_SRC

* Replacing Tables
At some point, we will need to replace the old table by the new one. The new one is stored in a list, though, so we need a way to make the list a string. The above code does just that: =tlt-nd-make-linestring= makes a string for every row, =tlt-nd-make-table= repeates this for every row to get the whole table. =tlt-ns-insert-table= inserts and aligns the table at point and =tlt-nd-replace-table= replaces the current table by that table.
#+BEGIN_SRC elisp :exports code
  (defun tlt-nd-make-linestring (line)
    "Return the table string of LINE. If LINE is 1, add an h-line-string."
    (if (= line 1)
        (concat "|"
                (string-join (tlt-nd-line line) "|") "|\n|---")
      (concat "|"
              (string-join (tlt-nd-line line) "|") "|")))

  (defun tlt-nd-make-table ()
    "Create a table from the data stored in `tlt-nd-table'."
    (let ((line 1)
          (length (length tlt-nd-table))
          (table ""))
      (while (<= line length)
        (setq table 
              (concat table (tlt-nd-make-linestring line) "\n"))
        (setq line (1+ line)))
      table))

  (defun tlt-nd-insert-table ()
    "Insert the table stored in `tlt-nd-table' at point."
    (save-excursion
      (insert (tlt-nd-make-table))
      (org-table-align)))

  (defun tlt-nd-replace-table ()
    "Delete the table at point and replace it with the table stored in `tlt-nd-table'."
    (let ((marker (point))
          (beg (org-table-begin))
          (end (org-table-end)))
      (delete-region beg end)
      (tlt-nd-insert-table)
      (goto-char marker)
      (re-search-forward "[^|]*" )
      (skip-chars-backward "\s\t")))
#+END_SRC

#+RESULTS:
: tlt-nd-replace-table

#+BEGIN_SRC elisp :exports code
  (defun tlt-nd-get-longest-string (strlist)
    "Return length of longest string in STRLIST."
    (let ((length 0))
      (dolist (str strlist)
        (let ((strlength (length str)))
          (if (> strlength length)
              (setq length strlength)
            )))
      length))

  (defun fill-star (num starstr)
    "Fill the stars fields of STARLIST after their last star with occurrences of '-' until the maximum star level. If NUM is the the length of STARSTR, return STARSTR.
Examples: 
num 4, starstr'-+' → '-+--'.
num 2, starstr'-++' → '-++'."
    (let* ((length (length starstr))
           (diff (- num length)))
      (if (> diff 0)
        (concat starstr
                (make-string diff ?-))
  starstr)))
#+END_SRC

#+RESULTS:
: fill-star

