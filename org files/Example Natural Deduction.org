| Sterne | Zeile | Formel  | Bezug | Regel |
|--------+-------+---------+-------+-------|
| +--    |     1 | $p$     | -     | Hyp   |
| -+-    |     2 | $p \to q$ | -     | Hyp   |
| +--    |     3 | $p \lor q$ | 1     | $I\lor$  |
| +--    |     4 | $q$     | 1,3   | $E\to$  |
| --+    |     5 | $r$     | -     | Hyp   |
| +-+    |     6 | $q \land r$ | 4,5   | $I\land$  |



| Sterne | Zeile | Formel  | Bezug | Regel |
|--------+-------+---------+-------+-------|
| +--   |     1 | $p$     | -     | hyp   |
| +--    |     2 | $p \lor q$ | 1     | $I\lor$  |
| -+-   |     3 | $p \to q$ | -     | hyp   |
| --+   |     4 | $r$     | -     | hyp   |
| ++- |     5 | $q$     | 1,3   | $E\to$  |
| +++  |     6 | $q \land r$ | 4,5   | $I\land$  |

- get first element of table (that is, first row)
- get the rule number, reference line and starstring
- get the properties of the proof rule
- check number of references → error if not correct
- function to do the right things with stars
- next row

(defun tryit ()
(tlt-nd-get-table)
(adjust-numbers)
(tlt-nd-correct-stars))


* TLT-ND-NEW does not work if there is just one hyp

| tlt-nd-new       | (list rownum starcol hyps-total) |
| tlt-nd-adopt     | (list rownum starcol refnums)       |
| tlt-nd-new       | (list rownum starcol hyps-total)  |
| tlt-nd-new       | (list rownum starcol hyps-total)  |
| tlt-nd-intersect | hyplist                             |
| tlt-nd-unite     | hyplist                             |
|                  |                                       |

(insert (format "%s" tlt-nd-table))


((Sterne Zeile Formel Bezug Regel) ( +-- 1 $p$ - Hyp) ( +-- 2 $p \lor q$ 1 $I\lor$) ( -+- 3 ($p \to q$ - Hyp) ( --+ 4 $r$ - Hyp) (+ 5 $q$ 1,3 $E\to$) (+ 6 $q \land r$ 4,5 $I\land$))


(( Sterne  Zeile  Formel  Bezug  Regel) 
(+-- 1  $p$  -  Hyp) 
(+-- 2  $p \lor q$ 1  $I\lor$)
(-+- 3  ($p \to q$ -  Hyp)
(--+ 4  $r$ -  Hyp)
( + 5  $q$ 1,3  $E\to$)
( + 6  $q \land r$ 4,5  $I\land$))


(( Sterne  Zeile  Formel  Bezug  Regel) ( + 1  $p$  -  Hyp) ( + 2  $p \lor q$ 1  $I\lor$) ( + 3  ($p \to q$ -  Hyp) ( + 4  $r$ -  Hyp) ( + 5  $q$ 1,3  $E\to$) ( + 6  $q \land r$ 4,5  $I\land$))


(( Sterne  Zeile  Formel  Bezug  Regel) (+-- 1  $p$  -  Hyp) (+-- 2  $p \lor q$ 1  $I\lor$) (-+- 3  $p \to q$ -  Hyp) (nil 4  $r$ -  Hyp) ( ++- 5  $q$ 1,3  $E\to$) ( +++ 6  $q \land r$ 4,5  $I\land$))

(( Sterne  Zeile  Formel  Bezug  Regel) (+-- 1  $p$  -  Hyp) (+-- 2  $p \lor q$ 1  $I\lor$) (-+- 3  $p \to q$ -  Hyp) (nil 4  $r$ -  Hyp) ( + 5  $q$ 1,3  $E\to$) ( + 6  $q \land r$ 4,5  $I\land$))


1. Create a (yet empty) list of hypotheses
2. Create a list of pending references to follow, whose elements are (at first) the reference lines of the current row.
3. Take the first row in that list, remove it and look up its reference line:
   1. If the reference line is non-empty, push the references to the list.
   2. If the reference 
      4. 
         5. 
2 → end
6 → 3 → end
6 → 5 → 2 → end
6 → 5 → 4 → 1 → end
6 → 5 → 4 → 3 → end


[[file:../../../../../media/storage/sciebo privat/org-mode/Bilder/2022-07-11_02-12-29_screenshot.png]]

*Beispiel Zeile 7 (ref: 2,6)*
1. Get reference string of current line
2. Loop: Get star string of every reference line.
3. Return a list of these stars.
tlt-nd-table
#+BEGIN_SRC elisp :exports code
      (defun tlt-nd-correct-stars ()
        "Correct stars."
        (let ((hypno 1)
              (row 1) ; leave out column row
              (rownum (1- (length tlt-nd-table)))
              (rulecol (car tlt-nd-rule))
              (refcol (car tlt-nd-reference))
              (starcol (car tlt-nd-stars)))

          (while (<= row rownum)
            (let* ((rowlist (nth row tlt-nd-table))    ; e.g. ("++" "3" "q" "1,2" "E->")
                   (rulestring (string-trim-left 
                                (nth (1- rulecol) rowlist)))       ; e.g. "Hyp"
                   (refstring (nth (1- refcol) rowlist))           ; e.g. "1,2"
                   (refsplit (split-string refstring ","))     n    ; e.g. ("1" "2")
                   (refnums (mapcar #'string-to-number
                                    refsplit))                     ; e.g. (1 2)
                   (refact (length refnums))                       ; e.g. 2
                   (starstring (nth (1- starcol) rowlist))           ; e.g. "++"
                   (rule (tlt-nd-find-rule rulestring))            ; e.g. (:rule hyp :names ("Hyp" "$Hyp$" ...) 

                   (refs (plist-get rule :refs))                   ; e.g. 2
                   (star-function (plist-get rule :star-function)) ; e.g. tlt-nd-new
                   (star-args (plist-get rule :args))              ; the argument list

                   (hyplist (tlt-nd-trace-hypotheses 
                                 starcol refnums))                ; trim off whitespace left
                   (hyps-total (tlt-nd-count-hyps)))

              ;;                                 (setq row (1+ row))

              ;; (push (list star-function star-args) try))
              ;;   )))
              ;;                                 ;


              ;; check references ;;
              (unless (or 
                       (member star-function tlt-nd-no-ref-rules)          ; if the rule is not a no-reference-rule
                       (equal (length refnums) refs))                      ; or if the correct number of refs is not the one provided
                (error "%s reference%s provided in row %d, although %s needed" ; signal an error
                       refact 
                       (if (> 1 refact) "s" "") 
                       row 
                       refs)) 

              ;; Set the star string depending on the rule of that row ;;

             (apply star-function (eval star-args))
              ;; If we're at a hypothesis, increment the hypothesis counter by 1 ;;
              (when (equal (plist-get rule :rule) 'hyp) ;
                (setq hypno (1+ hypno)))
              (setq row (1+ row))))
  tlt-nd-table))
#+END_SRC


hyplist
